# Subset of the MIPS ISA Processor with I/O
In this project I made a CPU that implements a subset of the MIPS ISA, as specified in the famous Onur Mutlu “Digital Design & Computer Architecture” course labs 2020 edition.
## Processor overview
This is the processor overview as outlined by the course and the reference textbook. The processor was later developed to realize additional instructions and include signals that help in debugging.

The processor implements a subset of the MIPS ISA; specifically it implements `j`, `beq`, `lw`, `sw`, `addi` and the R-type instructions specified in the ALU (a total of 15 instructions).

The processor works by loading hexadecimal 32-bit MIPS instructions from the instruction memory described in a text file named `insmem_h.text` into a register. This file is generated by dumping the compiled assembly code output in a text file. Likely, the data memory is fetched from a text file named `datamem_h.text` and loaded into a register. Both memories hold 64 addresses.

`Mips_Test.v` test file was used to verify the processor with the help of the DATA and ADDRESS output debug signals; This was done by inspecting the waveform at different intervals and comparing the `DATA` and `ADDRESS` outputs with the correct outputs I learned by running the assembly program in a the MARS stimulator ( MIPS assembly stimulator).

I/O devices are used when the address falls into I/O  address range, which is defined as `7ff`  i.e. `IsIO = ALUResult[31:4] == 28'h00007ff ? 1 : 0`
![image](https://github.com/OmarNehad/MIPS_Processor/assets/52573189/304de035-3828-478a-bcd3-c3654bced8e6)
## ALU unit

The ALU unit implements the following instructions:

| AluOp (6-bits) | Mnemonic | Result | Description |
| --- | --- | --- | --- |
| 000000 | add | A+B | Addition |
| 100010 | sub | A-B | Subtraction |
| 000100 | and | A and B | Logical and |
| 000101 | or | A or B | Logical or |
| 000110 | xor | A xor B | Exclusive or |
| 000111 | nor | A nor B | Logical nor |
| 001010 | slt | (A-B)[31] | Set less than |
| 010010 | mflo | result = lo | Propagates lo  register value into the output |
| 011001 | mutlu | A * B | Multiplication, saves the result in a local register named lo |
| 000010 | srl | B >> ShAmt | Shift B by Shift amount |

💡 `ALU_test.v` testbench file along with the `MIPS_test.v` were used to verify the ALU.

## Control unit
![image](https://github.com/OmarNehad/MIPS_Processor/assets/52573189/2a849add-0699-401e-afca-672d462a1d8b)
- In the case of the `addi` instruction, the ALU performs the `add` operation to calculate a + b where b is the specified immediate.
- In the case of the `lw`, `sw` instructions, the Control unit sets `AluOp` to the `add` operation to calculate the result (base + offset ) address needed. Additionally some control signals are defined to specify the register/memory read or write
- In the case of the branch instructions `beq`, the Control unit sets `AluOp` to the `sub` operation to calculate the comparison result.

💡 IO related control signals are defined in the datapath instead in the control unit, which is generally better than separating the controller from the datapath as it is done here. The book used this way as it just easier to explain and understand.
